
#' Plot trendsceek test-statistics
#'
#' \code{plot_trendstats} plots the trend-statistics by radius for a set of genes
#'
#' @param trendstat_list A list containing results generated by calling \code{trendsceek_test}.
#' @param sel_genes A character vector specifying the names of the mark distributions (genes) to be plotted
#' @param order_method A character vector specifying how the genes should be sorted in the plot.
#' Options include: 'markcorr', 'markvario', 'Emark' and 'Vmark'.
#' 
#' @examples
#' pp = sim_pois(300)
#' low_expr = c(10, 10)
#' high_expr = c(20, 50)
#' pp = add_markdist_hotspot(pp, low_expr, high_expr)
#' trendstat_list = trendsceek_test(pp, nrand = 100, ncores = 1)
#' sig_list = extract_sig_genes(trendstat_list, alpha = 0.1)
#' sig_genes = sig_list[['markcorr']][, 'gene']
#' plot_trendstats(trendstat_list, sig_genes)
#'
#' @export
plot_trendstats <- function(trendstat_list, sel_genes, order_method = 'markcorr'){

    if(length(sel_genes) == 0){
        stop("Argument 'sel_genes' is of length 0.")
    }
    
    tstat_list = trendstat_list[['tstat']]
    supstats_list = trendstat_list[['supstats']]
    
    ##wide -> long
    rstat_list = lapply(tstat_list, function(jgene.list){lapply(jgene.list, '[[', 'r.stat')})
    rstats.df = reshape2::melt(rstat_list, id.vars = colnames(rstat_list[[1]][[1]]))
    colnames(rstats.df)[(ncol(rstats.df)-1):ncol(rstats.df)] = c('test', 'gene')
    
    ##subset on sel_genes
    sub_rstats_df = merge(rstats.df, as.matrix(sel_genes), by.x = 'gene', by.y = 1)

    ##order genes by rank
    sub_supstats_df = merge(supstats_list[[order_method]], as.matrix(sel_genes), by.x = 'gene', by.y = 1)
    sel_genes_ordered = sub_supstats_df[order(sub_supstats_df[, 'rank']), 'gene']
    
    ##plot stats
    plot_rstats(sub_rstats_df, sel_genes_ordered)
}

plot_rstats <- function(rstats.df, genes.ordered = NA, global = TRUE, gene.id = ''){

    ##order genes
    if(gene.id == 'ensg'){
        rstats.df[, 'ensg'] = factor(rstats.df[, 'ensg'], levels = genes.ordered)
        rstats.df = rstats.df[order(rstats.df[, 'ensg']), ]
        rstats.df[, 'gene'] = factor(rstats.df[, 'gene'], levels = rstats.df[, 'gene'])
    }else{
        if('gene' %in% colnames(rstats.df)){
            rstats.df[, 'gene'] = factor(rstats.df[, 'gene'], levels = genes.ordered)
        }
    }
        
    if(global){
        ymin = 'lo.global'
        ymax = 'hi.global'
    }else{
        ymin = 'lo.local'
        ymax = 'hi.local'
    }
    
    ##construct gg
    gg = ggplot2::ggplot(rstats.df, ggplot2::aes_string(x = 'r'))
    gg = gg + ggplot2::geom_ribbon(ggplot2::aes_string(ymin = ymin, ymax = ymax), fill = 'grey70')
    gg = gg + ggplot2::geom_line(ggplot2::aes_string(y = 'exp'), linetype = 'dashed', colour = 'red')
    gg = gg + ggplot2::geom_line(ggplot2::aes_string(y = 'obs'))

    if('gene' %in% colnames(rstats.df)){
        gg = gg + ggplot2::facet_wrap(gene ~ test, scales = 'free', ncol = length(unique(rstats.df[, 'test'])))
    }else{
        gg = gg + ggplot2::facet_wrap( ~ test, scales = 'free')
    }

    
    ##Background
    gg = gg + ggplot2::theme(panel.grid.major = ggplot2::element_blank(), panel.grid.minor = ggplot2::element_blank(), axis.line = ggplot2::element_line(colour = "black")) + ggplot2::theme(panel.background = ggplot2::element_blank())
    gg = gg + ggplot2::theme(axis.line.x = ggplot2::element_line(color="black", size = 0.5), axis.line.y = ggplot2::element_line(color="black", size = 0.5))
    gg = gg + ggplot2::theme(axis.text.x = ggplot2::element_text(colour="black"), axis.text.y = ggplot2::element_text(colour="black"), axis.ticks = ggplot2::element_line(colour = 'black'))
    gg = gg + ggplot2::ylab('')

    ##plot
    graphics::plot(gg)
}

plot_prep <- function(pp, log_marks = TRUE, scale_marks = TRUE){

    marx = as.matrix(pp[['marks']])
    pointpos = cbind(pp[['x']], pp[['y']])
    colnames(pointpos) = c('x', 'y')
    if(is.null(rownames(marx))){
        rownames(marx) = paste('p', 1:nrow(marx), sep = '')
    }    
    rownames(pointpos) = rownames(marx)    
    ##rownames(marx) = rownames(pointpos)
    if(is.null(colnames(marx))){
        colnames(marx) = paste('g', 1:ncol(marx), sep = '')
    }
    
    if(log_marks){
        ##Log
        marx = log10(marx + 1)
    }

    ##Rescale to 0-1 for each gene as facet_wrap does not support free colour scales
    if(scale_marks){
        marx = apply(marx, 2, function(j.gene){j.gene = j.gene - min(j.gene); j.gene = j.gene / max(j.gene); return(j.gene);})
    }
    
    ##wide -> long
    marx_long = reshape2::melt(marx)
    colnames(marx_long) = c('cell', 'gene', 'expr')
    factor.cols = colnames(marx_long)[which(unlist(lapply(marx_long, is.factor)))]
    marx_long[, factor.cols] = lapply(marx_long[, factor.cols], as.character)

    ##add cell positions
    gg.data = merge(marx_long, pointpos, by.x = 'cell', by.y = 'row.names')

    return(gg.data)
}

#' Plot scatter-plot of point pattern
#'
#' \code{plot_pp_scatter} plots a scatter-plot of a point-pattern
#'
#' @param pp A point pattern
#' @param pointsize.factor A numeric determining the size of the plotted points
#' @param palette If a string, will use that named palette. If a number, will
#' index into the list of palettes of appropriate ‘type’ (see ggplot2::scale_colour_distiller).
#' @param pal.direction Sets the order of colors in the scale. If 1, the default, colors are as output by ‘brewer.pal’. 
#' If -1, the order of colors is reversed.
#' @param log_marks A logical specifying if log10 should be applied to the marks.
#' @param scale_marks A logical specifying if marks shoule be scaled to [0-1].
#' 
#' @examples
#' pp = sim_pois(100)
#' low_expr = c(10, 10)
#' high_expr = c(15, 20)
#' pp = add_markdist_hotspot(pp, low_expr, high_expr)
#' plot_pp_scatter(pp)
#' 
#' @export
plot_pp_scatter <- function(pp, pointsize.factor = 7.5, palette = 'Spectral', pal.direction = 1, log_marks = TRUE, scale_marks = TRUE){

    gg.data = plot_prep(pp, log_marks, scale_marks)

    ##Params
    genes = unique(gg.data[, 'gene'])
    n.genes = length(genes)
    point.size = pointsize.factor / n.genes

    ##Preserve order of genes
    marks.genes = colnames(pp[['marks']])
    if(length(which(marks.genes %in% genes)) == n.genes){
        gg.data[, 'gene'] = factor(gg.data[, 'gene'], levels = marks.genes)
    }
    
    ##*###
    ##Scatter plot
    ##*###
    gg = ggplot2::ggplot(gg.data, ggplot2::aes_string(x = 'x', y = 'y'))
    gg = gg + ggplot2::geom_point(size = point.size, ggplot2::aes_string(colour = 'expr'))

    ##wrap
    gg = gg + ggplot2::facet_wrap(~gene)

    gg = gg + ggplot2::scale_colour_distiller(palette = palette, direction = pal.direction)

    ##For dataset BC: reverse y-axis to better agree with the staining image in Fig 4C of the paper
    gg = gg + ggplot2::scale_y_reverse()

    ##bg
    gg = gg + ggplot2::theme(panel.grid.major = ggplot2::element_blank(), panel.grid.minor = ggplot2::element_blank(), axis.line = ggplot2::element_line(colour = "black")) + ggplot2::theme(panel.background = ggplot2::element_blank())
    gg = gg + ggplot2::theme(axis.line.x = ggplot2::element_line(color="black", size = 0.5), axis.line.y = ggplot2::element_line(color="black", size = 0.5))
    gg = gg + ggplot2::theme(axis.text.x = ggplot2::element_text(colour="black"), axis.text.y = ggplot2::element_text(colour="black"), axis.ticks = ggplot2::element_line(colour = 'black'))
    gg = gg + ggplot2::xlab('') + ggplot2::ylab('')
    
    ##plot
    ##pdf.w = 10
    ##pdf.h = 10
    graphics::plot(gg)
}

#' Plot density-plot of point pattern
#'
#' \code{plot_pp_density} plots a density-plot of a point-pattern
#'
#' @param pp A point pattern
#' @param pointsize.dens2d.factor A numeric determining the size of the plotted points
#' @param log_marks A logical specifying if log10 should be applied to the marks.
#' @param cells2highlight An indicator matrix (cells x genes) specifying which cells to highlight as red points for every gene. The output from \code{get_sigcells} can be used as input.
#' 
#' @examples
#' pp = sim_pois(100)
#' low_expr = c(10, 10)
#' high_expr = c(15, 20)
#' pp = add_markdist_hotspot(pp, low_expr, high_expr)
#' plot_pp_density(pp)
#' 
#' @export
plot_pp_density <- function(pp, pointsize.dens2d.factor = 7.5 / 20, log_marks = FALSE, cells2highlight = NA){
    
    gg.data = plot_prep(pp, log_marks, scale_marks = TRUE)

    if(!is.logical(cells2highlight)){
        cells_namecol = tibble::rownames_to_column(cells2highlight, var = 'cell')
        cells_long = tidyr::gather_(cells_namecol, 'gene', 'sig.cell', colnames(cells_namecol)[colnames(cells_namecol) != "cell"])
        gg.data = dplyr::inner_join(gg.data, cells_long, by = c('cell', 'gene'))
    }
    
    ##Params
    genes = unique(gg.data[, 'gene'])
    n.genes = length(genes)

    ##Preserve order of genes
    marks.genes = colnames(pp[['marks']])
    if(length(which(marks.genes %in% genes)) == n.genes){
        gg.data[, 'gene'] = factor(gg.data[, 'gene'], levels = marks.genes)
        genes = marks.genes
    }

    
    ##*###
    ##2D density plot
    ##*###
    expr_perc = round(gg.data[, 'expr'] * 100)
    expr_perc = expr_perc + 1
    gg.data = cbind(gg.data, expr_perc)
    gg.weighed = with(gg.data, gg.data[rep(1:nrow(gg.data), expr_perc),])
    point.size = pointsize.dens2d.factor / n.genes

    gg_list = list()
    n_plot_cols = ceiling(sqrt(n.genes))
    ##print(n_plot_cols)
    for(j_gene in genes){
        
        gg.sel = dplyr::filter_(gg.weighed, ~gene == j_gene)
        
        ##create gg
        gg = ggplot2::ggplot(gg.sel, ggplot2::aes_string(x = 'x', y = 'y'))
        gg = gg + ggplot2::stat_density_2d(geom = "raster", ggplot2::aes_string(fill = '..density..'), contour = FALSE)
        ##Raster is nicer than polygon: gg = gg + ggplot2::stat_density_2d(ggplot2::aes(fill = ..level..), geom = "polygon")
        ##Points are not that pretty: gg = gg + ggplot2::stat_density_2d(geom = "point", ggplot2::aes(size = ..density..), n = 20, contour = FALSE)
        ##Contours are not that pretty: gg = gg + geom_density_2d()
        ##Adding points as background makes it hard to see: gg = gg + ggplot2::geom_point(colour = '#1B9E77', size = point.size)

        ##wrap
        gg = gg + ggplot2::facet_wrap(~gene)

        ##For dataset BC: reverse y-axis to better agree with the staining image "HE_layer2_BC.jpg" and Fig. 4C of the paper.
        gg = gg + ggplot2::scale_y_reverse()
        
        ##bg
        gg = gg + ggplot2::guides(fill=FALSE)
        gg = gg + ggplot2::theme(panel.grid.major = ggplot2::element_blank(), panel.grid.minor = ggplot2::element_blank(), axis.line = ggplot2::element_line(colour = "black")) + ggplot2::theme(panel.background = ggplot2::element_blank())
        gg = gg + ggplot2::theme(axis.line.x = ggplot2::element_line(color="black", size = 0.5), axis.line.y = ggplot2::element_line(color="black", size = 0.5))
        gg = gg + ggplot2::theme(axis.text.x = ggplot2::element_text(colour="black"), axis.text.y = ggplot2::element_text(colour="black"), axis.ticks = ggplot2::element_line(colour = 'black'))
        gg = gg + ggplot2::xlab('') + ggplot2::ylab('')
        
        if(!is.logical(cells2highlight)){
            jgene_cells2highlight = dplyr::filter_(gg.data, ~gene == j_gene, ~sig.cell == 1)
            gg = gg + ggplot2::geom_point(data = jgene_cells2highlight, mapping = ggplot2::aes_string(x = 'x', y = 'y'), colour = RColorBrewer::brewer.pal(9, 'Reds')[8], size = point.size)
        }
        
        gg_list[[j_gene]] = gg
    }

    ##plot
    ##pdf.w = 20
    ##pdf.h = 20
    multiplot(plotlist = gg_list, cols = n_plot_cols)
}

## Multiple plot function
##
## ggplot objects can be passed in ..., or to plotlist (as a list of ggplot objects)
## - cols:   Number of columns in layout
## - layout: A matrix specifying the layout. If present, 'cols' is ignored.
##
## If the layout is something like matrix(c(1,2,3,3), nrow=2, byrow=TRUE),
## then plot 1 will go in the upper left, 2 will go in the upper right, and
## 3 will go all the way across the bottom.
##
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {

    ## Make a list from the ... arguments and plotlist
    plots <- c(list(...), plotlist)

    numPlots = length(plots)

    ## If layout is NULL, then use 'cols' to determine layout
    if (is.null(layout)) {
        ## Make the panel
        ## ncol: Number of columns of plots
        ## nrow: Number of rows needed, calculated from # of cols
        layout <- t(matrix(seq(1, cols * ceiling(numPlots/cols)), ncol = cols, nrow = ceiling(numPlots/cols)))
    }

    if (numPlots==1) {
        print(plots[[1]])

    } else {
        ## Set up the page
        grid::grid.newpage()
        grid::pushViewport(grid::viewport(layout = grid::grid.layout(nrow(layout), ncol(layout))))

        ## Make each plot, in the correct location
        for (i in 1:numPlots) {
            print(i)
            ## Get the i,j matrix positions of the regions that contain this subplot
            matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))

            print(plots[[i]], vp = grid::viewport(layout.pos.row = matchidx$row,
                                  layout.pos.col = matchidx$col))
        }
    }
}

